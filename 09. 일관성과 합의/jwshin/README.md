# 9장. 일관성과 합의

## 1. 서론: 내결함성과 일관성의 긴장

- 분산 시스템은 **장애를 견디는 것**과 **바른 결과를 보장하는 것**을 동시에 추구해야 한다.
- 그러나 “모든 복제본이 같은 값을 보여준다”는 **강한 보장**은 네트워크 사정(지연·분할)과 직접 충돌한다.

<img width="621" height="463" alt="image" src="https://github.com/user-attachments/assets/a26100d7-86c0-444f-b57f-d8a23d767297" />

- 그림 9-1 (비선형성 예: 스포츠 실시간 스코어)
    - 동일한 질문(최종 점수)에 **클라이언트마다 다른 답**을 받는 상황을 그린다.
    - 각 복제본이 “자기 시각”에 맞춰 업데이트를 반영하므로 **최신 결과**가 뒤늦게 퍼지고, 사용자 경험은 혼란스럽다.
- 이 문제를 이해하려면 “**최종 일관성**” 같은 느슨한 보장부터, **선형성(linearizability)** 같이 강한 보장까지 스펙트럼을 알아야 한다.

## 2. 선형성(linearizability): “하나의 원자적 레지스터처럼 보이기”

- 선형성은 “**복제본이 여러 개라도, 모든 읽기/쓰기가 단일 시점의 한 레지스터에 실행된 것처럼** 보인다”는 **외부 일관성** 보장.
- 독립적인 여러 클라이언트가 동시에 요청해도 **전체 순서를 정할 수 있어야** 한다(“누가 먼저/나중”이 관찰과 모순 없이 설명됨).
- 책은 선형성 시스템을 **원자적 레지스터(atomic register)** 로 모델링한다. 연산은 read()/write(v)/compare-and-set(old,new).

### 그림 9-2–9-4 (선형성 타임라인 도해)

<img width="630" height="215" alt="image" src="https://github.com/user-attachments/assets/b535aa9f-7bbe-482e-8a98-d7db06190d7b" />

- 9-2: 세 클라이언트가 읽고 쓰는 동안 **읽기가 과거값을 되풀이**할 수 있음을 보임(단순 복제에선 쓰기 전파 지연으로 발생).

<img width="738" height="238" alt="image" src="https://github.com/user-attachments/assets/8a7764a1-21f8-4d71-b88a-0656177ca5c4" />

- 9-3: “**쓰기와 동시에 일어난 읽기**”는 새 값 또는 옛 값 중 하나를 반환할 수 있다. 그러나 **그 이후 모든 읽기는 새 값을** 반환해야 선형적이다.

<img width="605" height="316" alt="image" src="https://github.com/user-attachments/assets/617c227a-2fc7-4807-8762-d787922d9b2f" />

- 9-4: compare-and-set(CAS)까지 들어오면 **경쟁 상황을 한 순서**로 정리할 수 있어야 한다. CAS가 성공했을 때 그 사이의 모든 읽기/쓰기 결과가 **단조롭게** 이어진다(“마지막 읽기까지 영향”).

> 핵심: 선형성은 DB 내부 직렬성(트랜잭션 직렬화)과는 다른 개념이다.
> 
- 직렬성: **단일 노드의 트랜잭션 연산 간 충돌 해소**(동시 실행을 직렬 스케줄로 환원).
- 선형성: **복제 환경에서 최신값 관찰의 실시간 순서 일치**(외부 관찰과의 정합).

## 3. 선형성의 비용과 CAP 논의

- 선형성은 읽기조차 **리더를 거치거나(동기 복제)**, **순서를 보장하는 코디네이션 경로**를 거쳐야 해서 **지연이 커진다**.

<img width="553" height="310" alt="image" src="https://github.com/user-attachments/assets/7f9a2fdc-42bc-4fd6-a73b-61007c9c0f33" />

- **그림 9-7 (멀티 데이터센터)**
    - 서로 다른 DC 간 네트워크 지연이 크면 **전 세계적으로 선형 읽기**를 보장하기가 어렵다.
    - 실무에서는 **지역 리더**를 두거나, **읽기는 오래된 값 허용**(캐시·팔로워 읽기)로 지연을 줄이는 설계를 쓴다.

- CAP에 대한 정리:
    - “**C(일관성) vs A(가용성) 중 하나를 고른다**” 같은 단순 구호는 과장.
    - 중요한 것은 **네트워크 분할이 생겼을 때 어떤 동작을 택하느냐**다. 선형성을 택하면 분할 시 **일부 요청 거부/차단**이 불가피하다.
    - 책은 CAP을 **설계 대화의 출발점**으로 취급하되, 오늘날엔 **구체적 지연·장애 모델**로 문제를 정밀하게 다루자고 권한다.

## **4. 인과성 일관성과 “전체 순서가 꼭 필요한가?” (p.338–345)**

- 인과성 일관성(causal consistency): “**원인→결과** 순서만 지키면 된다”(전체 순서가 아니라 **부분 순서**).
    - 예: A가 글을 쓰고 B가 그 글에 댓글을 달았다면, **댓글만 먼저 보이는 일**은 없어야 한다.
- 전체 순서는 항상 정의할 수 없다(일부 사건은 **서로 비교 불가**). 선형성은 인과적 일관성보다 **강한 보장**이다.
- 인과성을 실무에서 지키는 법:
    - **세션 보장**(read-your-writes, monotonic reads),
    - **버전 벡터/논리 시계**로 원인관계 추적,
    - 클라이언트 측 **시각화/캐시 전략**.
- **선형성 대신 인과성**을 택하면 비용이 훨씬 낮다. 많은 소셜/협업 시스템이 이 모델을 채택한다.

<img width="589" height="283" alt="image" src="https://github.com/user-attachments/assets/7ffe1530-d7ec-4d01-a00f-cfbdea3a8a5c" />

- **그림 9-8 (램포트 타임스탬프)**
    - 물리 시계가 달라도 **논리 카운터**로 **인과 순서**를 보장한다(전체 순서는 보장하지 않음).
    - 카운터의 **최댓값**을 기억하여 다음 연산을 증가시키는 규칙이 핵심.

## 5. “타임스탬프로 전체 순서를 정할 수 있을까?” → 어렵다

- 물리 시계나 단조 증가 ID만으로는 **완전한 전체 순서**를 안정적으로 못 만든다(스큐·정지·네트워크 지연).
- **정말 전체 순서가 필요**할 땐 **전체 순서 브로드캐스트(TOB, atomic broadcast)** 가 해법.

## 6. 전체 순서 브로드캐스트(TOB)와 상태 기계 복제(SMR)

- **TOB 정의**: 모든 노드가 **같은 순서**로 **모든 메시지**를 받는다.
    - 신뢰성(reliable delivery) + 순서 보장(ordered delivery)이 동시에 필요.
- **상태 기계 복제(State Machine Replication)**:
    - 애플리케이션의 상태 변경을 **순서가 있는 로그**로 만들고, 모든 복제본이 **동일한 순서**로 **동일한 연산**을 적용한다.
    - 그러면 결과 상태가 **언제나 동일**하다 → 선형적 레지스터·CAS 같은 강한 추상도 **TOB 위에서 구현** 가능.
- **TOB ≒ 합의(consensus)**:
    - 한 메시지를 **로그의 다음 위치**에 배치하는 결정을 여러 노드가 **같이 동의**하는 과정이 합의다.
    - 따라서 TOB를 구현하면 사실상 합의를 수행한 셈(반대로 합의로 TOB도 구현 가능).

## 7. “읽기만 선형성으로 만들기”와 실전 고려

- 읽기를 선형적으로 만들고 싶다면, **로그의 순서**에 비춰 “내가 관찰한 값이 **현재 커밋된 최신 위치**에 부합하는가”를 확인해야 한다.
- increment-and-get 같은 원자적 연산도 **합의/TOB** 위에서 안전하게 구현된다.

## 8. 분산 트랜잭션과 원자적 커밋(2PC)

### 8-1. 문제 정의와 주의점

- 여러 노드에 걸친 트랜잭션을 **전부 커밋하거나 전부 중단**(all-or-nothing) 시켜야 한다.
- **2단계 커밋(2PC)** 은 이를 위한 표준 원자 커밋 프로토콜.
- **오해 금지**: 2PC(원자 커밋) ≠ 2PL(직렬성 잠금). 2PC는 **커밋 여부의 합의**, 2PL은 **동시성 제어**.

### 8-2. 2PC 흐름

1. **코디네이터**가 참가자들에게 *prepare* 요청 → 각 참가자는 로컬 트랜잭션을 **영구 로그에 prepare 기록** 후 “예/아니오” 회신.
2. 모두 **예(yes)** 면 코디네이터가 **commit** 전파(모두 커밋 기록), 하나라도 **아니오(no)** 면 **abort** 전파.
- 장점: 간단하고 다양한 DB/메시지 브로커/XA에서 표준 지원.

### 8-3. 한계와 위험

- **블로킹**: 코디네이터가 죽고 복구 전이라면 **의심스러운(in-doubt)** 상태가 오래가며, 참가자들은 **락을 잡은 채로 대기**해야 한다.
- XA(표준 API) 환경에선 **의심 상태 유지**·**휴리스틱 결정(heuristic)** 같은 **운영상 난제**가 많다.
- “**Exactly-once** 메시징”과 2PC를 엮어 **데이터베이스+브로커 간 정확히 한 번 처리**를 꿈꾸지만, 장애 시 복구·중복 처리가 얽혀 **현실성 낮음**.
- **정리**: 2PC는 **단일 데이터베이스 내부**에선 유용하지만, **이기종 시스템 간**에는 운영 비용과 위험이 크다.

## 9. 합의(Consensus)와 TOB의 실제 구현

### 9-1. 대표 알고리즘과 공통 속성

- **Viewstamped Replication(VSR)**, **Paxos**, **Raft**, **Zab**(ZooKeeper) 등.
- 공통 요구사항:
    - **균일한 동의**(두 노드가 상반된 결정을 내리지 않음),
    - **무결성**(이미 결정된 값을 또 바꾸지 않음),
    - **유효성**(제안된 값 중 하나가 선택),
    - **종료**(충분히 안정적이면 결국 결정).
- 합의는 **로그의 “다음 항목”을 결정**하는 일과 본질적으로 같다 → **전체 순서 브로드캐스트를 만든다**는 것과 동의.

### 9-2. 단일 리더 복제와 왜 합의가 필요한가

- 5장 단일 리더 복제에선 “리더가 최신 상태를 유지한다” 가정이 있었다.
- 하지만 **리더 선출/장애 복구 시점**, **스플릿-브레인 방지**, **중복된 리더 선언**을 해결하려면 **합의**가 필요하다.
- 합의는 리더의 권한을 **다수결 쿼럼**(과반수)로 뒷받침하여, **서로 다른 리더가 동시에 결정**하지 못하게 막는다.

### 9-3. 에포크(용어: epoch/term/ballot/view)와 정족수

- 리더 임기마다 번호(에포크/term)가 **단조 증가**.
- 어떤 제안이 유효하려면 **현재 임기의 리더가 과반 투표를 얻어야** 한다.
- 임기 전환 시 **이전 리더의 미완 요청**은 폐기되며, **로그 정합**을 맞춘 뒤 새 리더가 진행.

## 10. 멤버십과 코디네이션 서비스

- **문제**: 누가 참여자이며, 누가 살아 있는가? 어떤 노드가 리더를 맡나?
- **해법**: ZooKeeper / etcd / Consul 같은 **코디네이션 서비스**가
    - 선형성(또는 매우 강한 일관성)의 **작은 키-값 저장소**와,
    - **에포크/임대(lease)·펜싱 토큰·에페메럴 노드**(세션이 끊어지면 자동 삭제) 같은
    - **고가용 리더·락·멤버십** 원자 연산을 제공한다.
- 책의 권고:
    - **데이터 경로**(대용량 읽기/쓰기)는 애플리케이션 DB가 담당,
    - **제어 경로**(리더 선출, 락, 유일성 보장, 설정 관리)는 **코디네이션 서비스**를 통해 **작게·짧게** 처리.
- **서비스 찾기 vs 멤버십**
    - “어떤 서비스 인스턴스가 어디에 있는가?”(service discovery) 문제는 **DNS·레지스트리**로 해결 가능.
    - 그러나 “누가 ‘합의의 참여자’인가?”는 **동적 멤버십**으로 다루며, 합의 계층의 **일관성 경계** 안에서 관리해야 한다.

## 11. 마지막 정리: 언제 무엇을 쓸 것인가

- **선형성 보장 저장소**가 있으면 애플리케이션은 단일 스레드 프로그래밍과 유사한 단순 모델을 누릴 수 있다.
    - 단점: 지연과 비용. 전 세계/멀티 DC에선 특히 크다.
- **2PC**는 이기종 시스템을 **정확히 한 번**으로 묶어줄 것처럼 보이지만, **의심 상태·블로킹·운영 난제**가 크다.
- **합의/TOB/SMR**은 **작은 메타데이터·제어면**에 쓰고, 데이터면은 **복제·캐시·인과성 보장** 등 **덜 비싼 모델**을 섞는 것이 현실적이다.
- 책의 실무 지침(요약):
    1. **리더/락/유일성/메타데이터**는 합의 계층(코디네이션 서비스)으로 **짧고 작게** 처리.
    2. **사용자 데이터 경로**는 본 DB가 담당(읽기는 느슨한 보장 허용 여부를 서비스 요구에 맞춰 결정).
    3. 장애·네트워크 분할 시 **어떤 제약을 우선**할지(지연/가용성 vs 최신성/선형성) **명시적으로 선택**하라.
