# 12장. 데이터 시스템의 미래

## 1. 개요

- 지금까지는 **현재 존재하는 시스템**을 설명했다면, 이번 장은 **미래의 데이터 시스템이 어떻게 되어야 하는가**를 다룬다.
- 목표: **신뢰성·확장성·유지보수성**이 높은 시스템 설계 방향을 제시한다.
- 이전 장의 핵심 개념들(복제, 합의, 진화 등)을 종합해 미래 시스템의 **발전 가능성과 설계 원칙**을 탐구한다.

## 2. 데이터 통합

- 책 전반의 주제는 여러 문제에 대한 다양한 **해결책과 트레이드오프(절충점)** 을 비교하는 것이다.
- “데이터를 저장하고 나중에 조회하기” 같은 문제는 **단일한 정답이 없고**, 상황에 따라 다른 접근법이 더 적절할 수 있다.
- 소프트웨어는 특정 접근법 하나를 택해 안정적으로 동작하도록 설계되며, 모든 문제를 하나의 도구로 해결하려 하면 **유연성이 떨어진다**.
- 따라서 **상황에 맞는 도구 선택**이 중요하며, 각 도구는 특정 사용 방식과 트레이드오프를 전제로 만들어진다.
- 애플리케이션이 복잡할수록 **여러 도구를 조합**해야 원하는 기능을 구현할 수 있다.

### 2-1. 파생 데이터에 특화된 도구의 결합

- OLTP 데이터베이스는 기본적인 **키워드 질의** 정도는 처리할 수 있지만, **전문 검색**이나 **복잡한 탐색 기능**을 위해선 별도의 전문 도구가 필요하다.
- 따라서 보통 **검색 엔진 + 데이터베이스** 등 **두 도구를 결합**해 사용한다.
- 데이터가 다양한 방식으로 표현될수록, 시스템 간 **데이터 통합**은 점점 더 어려워진다.
- **데이터 통합과 도구 선택은 절대적 정답이 없고, 사용 목적과 환경에 맞춰 균형 잡힌 조합을 고려해야 한다.**

### 2-2. 데이터플로에 대한 추론

- 동일한 데이터를 여러 시스템에 저장해야 할 경우, **입력과 출력의 구분**, **기록 시점과 형식**, **업데이트 방식**을 명확히 정의해야 한다.
- 보통 데이터는 먼저 **레코드 데이터베이스**에 저장되고, **변경 데이터 캡처(CDC)** 를 통해 다른 시스템(검색, 분석 등)에 반영된다.
- CDC는 소프트웨어 버그가 없는 한 **일관성을 보장**하는 반면, 애플리케이션에서 직접 여러 시스템에 동시에 데이터를 기록하면 **순서 충돌**이나 **불일치** 문제가 발생할 수 있음.
- 따라서 **모든 쓰기 순서를 단일 시스템이 책임지는 구조**가 가장 안전하고 파생 데이터 복제가 쉽다.
- 이벤트 로그 기반 시스템은 **결정적이고 멱등적인(idempotent)** 갱신이 가능해 복구와 일관성 유지에 특히 유리하다.

### 2-3. 파생 데이터 vs 분산 트랜잭션

- **분산 트랜잭션(2PC)** 은 여러 데이터 시스템 간 일관성을 유지하는 고전적인 방식이다.
    
    반면 **파생 데이터 시스템**은 다른 접근으로 동일한 목표를 달성한다.
    
- 분산 트랜잭션은 **잠금(lock)** 을 이용해 쓰기 순서를 결정하지만,
    
    파생 데이터 시스템은 **로그를 통해 순서를 결정**한다.
    
- 분산 트랜잭션은 **정확히 한 번 처리(원자적 커밋)** 를 보장하고,
    
    로그 기반 시스템은 **재시도와 멱등성**으로 일관성을 유지한다.
    
- 트랜잭션 시스템은 **선형성(자신이 쓴 내용 읽기)** 을 제공하지만
    
    파생 데이터 시스템은 **비동기처리라**서 기본적으로 즉시 일관성을 보장하지 않는다.
    
- 분산 트랜잭션은 구현이 복잡하고 비용이 크기 때문에,
    
    실무에서는 로그 기반 파생 데이터 접근법이 **더 현실적이고 확장 가능**하다.
    
- 완벽한 일관성보다는 “**어떻게 일관성을 관리할지**”가 중요하며,
    
    비동기 파생 데이터 시스템은 그 중간 지점을 찾아 **확장성과 안정성**을 균형 있게 확보한다.
    

### 2-4. 전체 순서화의 제약

- **작은 시스템**에서는 이벤트 로그 전체의 순서를 보장하는 것이 가능하지만,
    
    **규모가 커지고 복잡한 분산 환경**에서는 한계가 생긴다.
    
- **데이터센터가 여러 지역에 분산**되면 네트워크 지연으로 인해 서로 다른 데이터센터의 이벤트 순서를 맞추기 어려워진다.
- **애플리케이션이 마이크로서비스 구조**일 경우, 각 서비스의 지속성과 상태 관리 단위가 독립적이므로 서비스 간 이벤트 순서를 전역적으로 정의하기 힘들다.
- 이처럼 **전역적인 순서 보장(전체 순서 브로드캐스트)** 은 분산 환경에서 매우 어려운 미해결 과제이며,
    
    현재로선 **단일 노드 수준의 순서 보장**만 현실적으로 가능하다.
    

### 2-5. 인과성 획득을 위한 이벤트 순서화

- **전체 순서가 정해지지 않아도 문제없는 경우**가 많지만, 특정 상황에서는 **이벤트 간 인과성(causality)** 이 중요해진다.
- 예: SNS에서 친구 관계를 끊은 직후 메시지를 보냈을 때,
    
    [친구 삭제] 이벤트보다 [메시지 보내기] 이벤트가 먼저 처리되면 의도하지 않은 메시지가 전달될 수 있다.
    
    → 인과성이 깨진 사례
    
- **인과성 유지 방법**
    - **타임스탬프 기반 논리적 순서화**: 이벤트 발생 시점을 기준으로 순서를 정의.
    - **사용자 결정 기록 기반**: 사용자가 내린 모든 상태 변경을 기록하고, 그에 따른 이벤트를 순서에 맞게 재생.
    - **충돌 해결 알고리즘 활용**: 동시에 발생한 이벤트를 병합하거나 조정해 일관성 확보.

### 2-5. 일괄 처리와 스트림 처리

- 두 방식 모두 **데이터를 변환하고 올바른 형태로 저장**하는 게 목적이다.
- **일괄 처리**는 유한한 입력을 한 번에 처리하고, **스트림 처리**는 끝없이 들어오는 데이터를 실시간으로 다룬다.
- 스트림 처리는 일괄 처리의 원리를 실시간으로 확장한 형태다.
- **마이크로 일괄 처리**는 스트림을 작은 단위로 쪼개 일괄 처리하는 절충 방식이다.
- 결과적으로 두 방식은 원리는 같지만 **입력의 형태와 처리 타이밍**이 다르다.

### 2-6. 파생 상태 유지

- **일괄 처리**는 함수형 프로그래밍처럼 입력을 불변 데이터로 처리해
    
    예측 가능한 결과를 내며, **명시적 입력 외 부수효과가 없다**.
    
- **스트림 처리** 역시 연산자를 확장해 상태를 관리하고 내결함성을 유지할 수 있다.
- 입력·출력을 명확히 정의하면 **내결함성 확보와 파이프라인 단순화**에 도움이 된다.
- 파생 데이터 시스템은 일반적으로 **비동기 로그 기반 방식**으로 동기화를 수행한다.
    
    이 방식은 시스템 간 결합을 줄이고 견고성을 높인다.
    
- 반면 **분산 트랜잭션**은 일부 실패가 전체 실패로 확산될 위험이 있다.

### 2-7. 애플리케이션 발전을 위한 데이터 재처리

- 애플리케이션을 발전시키려면 과거 데이터를 **재처리**해 새로운 파생 뷰로 반영할 수 있어야 한다.
- **스키마 변화와 차이**: 레코드에 필드 추가·타입 변경 같은 **스키마 수정만**으로는 한계가 있다. 전혀 다른 모델로 **재구축**하려면 과거 데이터 **재처리**가 필요하다.
- **비유(철도 스키마 이전)**: 표준이 달라 혼재되던 궤간을 점진적으로 표준화하듯, 기존 뷰를 유지한 채 **새 뷰를 병행 운영**하며 점진적 이전을 진행.
- 제안 전략:
    - 기존 뷰와 새로운 뷰를 **동시에 유지**(dual run) → 일부 트래픽을 새 뷰로 보내 성능·버그 검증.
    - 점차 새로운 뷰 비중을 높이고 문제가 없으면 **스위칭.**
- **장점**: 롤백 가능성 확보(이전 뷰가 남아 있음), 실패 위험 낮춤, 사용자 영향 최소화, 빠른 개선 사이클.
- **요약**: 스키마만 바꾸는 수정이 아니라, **데이터 재처리로 새 모델을 세워 병행 운영 후 점진 이전**이 현실적인 진화 메커니즘.

### 2-8. 람다 아키텍처

- 람다 아키텍처의 핵심 아이디어: 입력 데이터를 불변 이벤트로서 증가하기만 하는 데이터셋에 추가하는 방식으로 기록해야 한다. 이 입력 데이터를 일괄 처리로 과거 데이터를 재처리하고, 스트림 처리로 최신 데이터를 빠르게 반영
- why? 일괄 처리는 정확하지만 느리고, 스트림 처리는 빠르지만 근사값 기반이라 두 방식을 병행한다.
- 그러나 두 시스템을 함께 운영하면 코드와 인프라 중복, 운영 복잡도 증가, 동일한 로직을 두 번 구현해야 하는 비효율 발생

### 2-9. 일괄 처리와 스트림 처리의 통합

- **일괄+스트림 통합 추세**: 한 시스템에서 과거 데이터 재처리(일괄)와 실시간 처리(스트림)를 함께 지원해 람다 아키텍처의 중복을 줄이는 방향으로 진화하고 있다.
- **과거 재생 가능**: 로그 기반 브로커/분산 파일 입력을 통해 과거 이벤트를 다시 읽어 동일한 결과를 재현할 수 있어야 한다(리플레이).
- **정확히 한 번 의미**: 장애/재시작 시에도 중복 없이 동일 출력이 되도록 정확히 한 번(혹은 결과적으로 한 번) 시맨틱을 제공해야 한다.
- **이벤트 시간 기반 윈도우**: 처리 시간 아닌 이벤트 시간으로 집계 윈도우를 정의·계산해야 과거 이벤트 재처리 시 의미가 맞다.
- **표준화된 API/런타임**: 동일 파이프라인을 배치·스트림 모두에서 실행할 수 있는 추상화가 필요하다(예: Apache Beam API, Flink/Cloud Dataflow 등).

## 3. 데이터베이스 언번들링

- 데이터베이스와 운영체계는 모두 데이터를 저장·관리하는 시스템이라는 점에서 유사하다.
- 차이는 접근 방식에 있음 — 운영체계는 파일 단위, 데이터베이스는 레코드 단위로 관리한다.
- 유닉스는 하드웨어 근처의 저수준 추상화, 데이터베이스는 SQL·트랜잭션 등 고수준 기능을 제공한다.

### 3-1. 데이터 저장소 기술 구성하기

- 데이터베이스는 다음과 같은 다양한 기능을 제공한다.
    - 보조 색인: 필드 값 기반으로 레코드를 효율적으로 검색한다.
    - 구체화 뷰: 질의 결과를 미리 연산해 일정히 유지한다. → 캐시의 일종이다.
    - 복제 로그: 데이터 복사본을 다른 노드에 최신 상태로 유지하는 기능이다.
    - 전문 검색 색인: 텍스트 내 키워드 검색을 지원한다.
- 이러한 기능들은 일괄 처리와 스트림 처리 모두에 활용 가능하다.
- 데이터베이스의 기능은 파생 데이터 시스템 설계와 밀접한 관련이 있다.

### 3-2. 색인 생성하기

- 관계형 데이터베이스에서 CREATE INDEX 실행 시, 테이블 전체를 스캔해 색인 필드 값을 정렬하고 기록한다.
- 이후에는 테이블 변경 시마다 색인을 갱신해 최신 상태를 유지한다.
- 이 과정은 **새 팔로워 복제본을 만드는 과정**이나 **스트림 시스템의 변경 데이터 캡처(CDC)** 와 유사하다.
- 결국 색인 생성은 **초기 스냅샷 + 변경 로그 반영** 구조로 이루어진다.

### 3-3. 모든 것의 메타데이터베이스

- 일괄 처리·스트림 처리·ETL은 모두 **데이터를 변환·갱신해 최신 상태를 유지**하는 과정이다.
- 파생 데이터 시스템은 결국 **데이터베이스의 확장된 형태**로 볼 수 있다.
- **연합 데이터베이스**는 여러 저장소를 **읽기 기반으로 통합**해 단일 질의 인터페이스를 제공한다.
- **언번들링 데이터베이스**는 **쓰기 기반 통합**으로, 변경 이벤트를 여러 시스템에 전파해 일관성을 유지한다.
- 결국 두 접근은 모두 **분산된 데이터 시스템을 통합하는 서로 다른 방식**이다.

### 3-4. 언번들링이 동작하게 만들기

- 여러 저장소 간 **쓰기 동기화**는 엔지니어링적으로 어려운 문제이며, 전통적 접근은 **분산 트랜잭션(2PC)** 기반이었다.
    
    하지만 저자는 이 방식을 비효율적이라 보고, 대신 **비동기 이벤트 로그**를 활용한 접근이 더 현실적이라고 설명한다.
    
- **이벤트 로그 기반 접근의 장점**
    - 쓰기 순서가 명확해지고, 이벤트 로그를 통해 시스템 간 일관성을 비교적 쉽게 맞출 수 있다.
    - 트랜잭션처럼 강한 결합이 필요 없고, 시스템 간 느슨한 연결(loose coupling)을 유지한다.
- **느슨한 결합의 효과**
    - **확장성과 장애 내성 향상**
        - 비동기 이벤트 스트림을 사용하면 일부 장애가 발생해도 전체 시스템은 지속적으로 동작 가능.
        - 결합된 시스템보다 지역적 장애가 전체로 확산될 가능성이 낮다.
    - **조직적 유연성**
        - 각 팀이 자신들의 데이터 시스템을 **독립적으로 개발·개선** 가능.
        - 인터페이스만 잘 정의하면 다른 팀과의 통합도 자연스럽게 이루어짐.
        - 즉, 기술적 결합뿐 아니라 **조직적 결합도 완화**할 수 있다.
